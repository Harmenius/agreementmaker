package agreementMaker.application.mappingEngine;

import java.util.ArrayList;
import java.util.Iterator;

import agreementMaker.application.Core;
import agreementMaker.application.ontology.Node;
import agreementMaker.application.ontology.Ontology;

public abstract class AbstractMatcher implements Matcher{
	
	/**Unique identifier of the algorithm used in the JTable list as index
	 * if an algorithm gets deleted we have to decrease the index of all others by one
	 * */
	private int index;
	/**Name of the algorithm, there should be also a final static String in the instance class
	 * in the constructor of the non-abstract class should happen "name = FINALNAME"
	 * */
	private String name;
	/**User mapping should be the only one with this variable equal to false*/
	private boolean isAutomatic;
	/**True if the algorithm needs parameter, in this case the developer must develop a JFrame to let the user define them*/
	private boolean needsParam;
	/**Parameter of this method, if needsParam this item will be generated by the userinterface if not this will be automatically generated with default values*/
	private AbstractParameters param;
	/**True means that AM should show its alignments*/
	private boolean isShown;
	
	private double threshold;
	
	/**ANY means any numer of relations for source or target*/
	public final static int ANY = Integer.MAX_VALUE;
	private int maxSourceAlign;
	private int maxTargetAlign;
	
	/**Contain alignments, NULL if alignment has not been calculated*/
	private AlignmentSet propertiesAlignmentSet;
	private AlignmentSet classesAlignmentSet;
	
	/**Structure containing similarity values between classes nodes, matrix[source][target]
	 * should not be accessible outside of this class, the system should only be able to access alignments sets
	 * */
	private AlignmentMatrix classesMatrix;
	/**Structure containing similarity values between classes nodes, matrix[source][target]*/
	private AlignmentMatrix propertiesMatrix;
	
	/**Reference to the Core istances*/
	private Ontology sourceOntology;
	private Ontology targetOntology;
	
	/**If the algo calculates prop alignments*/
	public boolean alignProp;
	/**If the algo calculates prop alignments*/
	public boolean alignClass;
	/***Some algorithms may need other algorithms as input*/
	private ArrayList<AbstractMatcher> inputMatchers;
	/**Minum and maximum number of input matchers
	 * a generic matcher which doesn't need any inputs should have 0, 0
	 * */
	private int minInputMatchers;
	private int maxInputMatchers;
	
	
	public AbstractMatcher(int key, String n) {
		index = key;
		name = n;
		isAutomatic = true;
		needsParam = false;
		isShown = true;
		threshold = 0.75;
		maxSourceAlign = ANY;
		maxTargetAlign = 1;
		alignClass = true;
		alignProp = true;
		minInputMatchers = 0;
		maxInputMatchers = 0;
		//ALIGNMENTS LIST MUST BE NULL UNTIL THEY ARE CALCULATED
		sourceOntology = Core.getInstance().getSourceOntology();
		targetOntology = Core.getInstance().getTargetOntology();
		inputMatchers = new ArrayList<AbstractMatcher>();
	}
	
    public void match() {
    	if(maxInputMatchers > 0 && inputMatchers.size() > 0) {
    		analyzeInputMatchers();
    	}
    	align();
    	selectAndSetAlignments();						
    }

    private void analyzeInputMatchers() {
    	//TO BE OVERRIDDEN IN THE MATCHER IF IT HAS maxInputMatchers > 0
	}

	private void align() {
		if(alignClass) {
			ArrayList<Node> sourceClassList = sourceOntology.getClassesList();
			ArrayList<Node> targetClassList = targetOntology.getClassesList();
			classesMatrix = alignClasses(sourceClassList,targetClassList );			
		}
		if(alignProp) {
			ArrayList<Node> sourcePropList = sourceOntology.getPropertiesList();
			ArrayList<Node> targetPropList = targetOntology.getPropertiesList();
			propertiesMatrix = alignProperties(sourcePropList, targetPropList );					
		}

	}
	


	private AlignmentMatrix alignProperties(ArrayList<Node> sourcePropList, ArrayList<Node> targetPropList) {
		return alignNodesOneByOne(sourcePropList, targetPropList);
	}

	private AlignmentMatrix alignClasses(ArrayList<Node> sourceClassList, ArrayList<Node> targetClassList) {
		return alignNodesOneByOne(sourceClassList, targetClassList);
	}
	
	private AlignmentMatrix alignNodesOneByOne(ArrayList<Node> sourceList, ArrayList<Node> targetList) {
		AlignmentMatrix matrix = new AlignmentMatrix(sourceList.size(), targetList.size());
		Node source;
		Node target;
		Alignment alignment; //Temp structure to keep sim and relation between two nodes, shouldn't be used for this purpose but is ok
		for(int i = 0; i < sourceList.size(); i++) {
			source = sourceList.get(i);
			for(int j = 0; j < targetList.size(); j++) {
				target = targetList.get(j);
				alignment = alignTwoNodes(source, target);
				matrix.set(i,j,alignment);
			}
		}
		return matrix;
	}

	private Alignment alignTwoNodes(Node source, Node target) {
		//TO BE IMPLEMENTED BY THE ALGORITHM, THIS IS JUST A FAKE ABSTRACT METHOD
		double sim;
		String rel = Alignment.EQUIVALENCE;
		if(source.getLocalName().equals(target.getLocalName())) {
			sim = 1;
		}
		else {
			sim = 0;
		}
		return new Alignment(source, target, sim, rel);
	}
	
	private void selectAndSetAlignments() {
		if(maxSourceAlign == 1 && maxTargetAlign == 1) {
			//TO BE DEVELOPED USING MAX WEIGHTED MATCHING ON BIPARTITE GRAPH, SOLVED USING DAJKSTRA
			scanForMaxValues();//TO BE CHANGED
		}
		else if(maxSourceAlign != ANY && maxTargetAlign != ANY) {
			//TO BE DEVELOPED: I DON'T KNOW YET HOW TO DO THIS
			scanForMaxValues();//TO BE CHANGED
		}
		else {//ONE OF THE TWO CONSTRAINTs IS ANY, SO WE JUST HAVE TO PICK ENOUGH MAX VALUES TO SATISFY OTHER CONSTRAINT 
			scanForMaxValues();
		}
	}

	private void scanForMaxValues() {
		if(maxTargetAlign >= maxSourceAlign) {//Scan rows and then columns
			int numMaxValues = maxSourceAlign;
			if(alignClass)
				classesAlignmentSet = scanForMaxValuesRowColumn(classesMatrix, numMaxValues);
			if(alignProp)
				propertiesAlignmentSet = scanForMaxValuesRowColumn(propertiesMatrix, numMaxValues);
		}
		else {//scan columns and then rows
			int numMaxValues = maxTargetAlign;
			if(alignClass)
				classesAlignmentSet = scanForMaxValuesColumnRow(classesMatrix, numMaxValues);
			if(alignProp)
				propertiesAlignmentSet = scanForMaxValuesColumnRow(propertiesMatrix, numMaxValues);
		}
	}

	private AlignmentSet scanForMaxValuesRowColumn(AlignmentMatrix matrix, int numMaxValues) {
		AlignmentSet aset = new AlignmentSet();
		Alignment currentValue;
		Alignment currentMax;
		Alignment[] maxAlignments = new Alignment[numMaxValues];//temp structure to keep the first numMaxValues best alignments for each source
		for(int i = 0; i<matrix.getRows();i++) {
			for(int j = 0; j<matrix.getColumns();i++) {
				currentValue = matrix.get(i,j);
				int k = 0;
				currentMax = maxAlignments[k];
				for(k = 1; currentValue.getSimilarity() > currentMax.getSimilarity() && k < maxAlignments.length; k++) {
					maxAlignments[k-1] = currentValue;
					currentValue = currentMax;
					currentMax = maxAlignments[k];
				}
			}
			currentValue = maxAlignments[0];
			for(int e = 0;currentValue.getSimilarity() >= threshold && e < maxAlignments.length; e++) {
				currentValue = maxAlignments[e];
				aset.addAlignment(currentValue);
			}
		}
		return aset;
	}

	private AlignmentSet scanForMaxValuesColumnRow(AlignmentMatrix matrix,int numMaxValues) {
		AlignmentSet aset = new AlignmentSet();
		Alignment currentValue;
		Alignment currentMax;
		Alignment[] maxAlignments = new Alignment[numMaxValues];//temp structure to keep the first numMaxValues best alignments for each source
		for (int j = 0; j<matrix.getColumns();j++){
			for (int i = 0; i<matrix.getRows();i++){
				currentValue = matrix.get(i,j);
				int k = 0;
				currentMax = maxAlignments[k];
				for(k = 1; currentValue.getSimilarity() > currentMax.getSimilarity() && k < maxAlignments.length; k++) {
					maxAlignments[k-1] = currentValue;
					currentValue = currentMax;
					currentMax = maxAlignments[k];
				}
			}
			currentValue = maxAlignments[0];
			for(int e = 0;currentValue.getSimilarity() >= threshold && e < maxAlignments.length; e++) {
				currentValue = maxAlignments[e];
				aset.addAlignment(currentValue);
			}
		}
		return aset;
	}

	public AlignmentSet getAlignmentSet() {
    	AlignmentSet aligns = new AlignmentSet();
    	if(areClassesAligned()) {
    		aligns.addAll(classesAlignmentSet);
    	}
    	if(arePropertiesAligned()) {
    		aligns.addAll(propertiesAlignmentSet);
    	}
    	return aligns;
    }

    public AlignmentSet getClassAlignmentSet() {
    	return classesAlignmentSet;
    }

    public AlignmentSet getPropertyAlignmentSet() {
    	return propertiesAlignmentSet;
    }
    /**AgreementMaker doesn't calculate instances matching, if you add this you should also modify getAlignmenSet*/
    public AlignmentSet getInstanceAlignmentSet() {
    	System.out.println("trying to invoking a function not implemented yet");
    	return null;
    }
    
    public boolean areClassesAligned() {
    	return classesAlignmentSet != null;
    }
    
    public boolean arePropertiesAligned() {
    	return propertiesAlignmentSet != null;
    }

	public int getIndex() {
		return index;
	}

	public void setIndex(int index) {
		this.index = index;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public boolean isAutomatic() {
		return isAutomatic;
	}

	public void setAutomatic(boolean isAutomatic) {
		this.isAutomatic = isAutomatic;
	}

	public boolean isNeedsParam() {
		return needsParam;
	}

	public void setNeedsParam(boolean needsParam) {
		this.needsParam = needsParam;
	}

	public AbstractParameters getParam() {
		return param;
	}

	public void setParam(AbstractParameters param) {
		this.param = param;
	}

	public boolean isShown() {
		return isShown;
	}

	public void setShown(boolean isShown) {
		this.isShown = isShown;
	}

	public double getThreshold() {
		return threshold;
	}

	public void setThreshold(double threshold) {
		this.threshold = threshold;
	}

	public int getMaxSourceAlign() {
		return maxSourceAlign;
	}

	public void setMaxSourceAlign(int maxSourceAlign) {
		this.maxSourceAlign = maxSourceAlign;
	}

	public int getMaxTargetAlign() {
		return maxTargetAlign;
	}

	public void setMaxTargetAlign(int maxTargetAlign) {
		this.maxTargetAlign = maxTargetAlign;
	}

	public int getMinInputMatchers() {
		return minInputMatchers;
	}

	public void setMinInputMatchers(int minInputMatchers) {
		this.minInputMatchers = minInputMatchers;
	}

	public int getMaxInputMatchers() {
		return maxInputMatchers;
	}

	public void setMaxInputMatchers(int maxInputMatchers) {
		this.maxInputMatchers = maxInputMatchers;
	}

	public ArrayList<AbstractMatcher> getInputMatchers() {
		return inputMatchers;
	}
    
	public void addInputMatcher(AbstractMatcher a) {
		inputMatchers.add(a);
	}
	
}
