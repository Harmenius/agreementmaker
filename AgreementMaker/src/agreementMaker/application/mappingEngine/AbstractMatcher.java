package agreementMaker.application.mappingEngine;

import java.util.ArrayList;
import java.util.Iterator;

import agreementMaker.application.Core;
import agreementMaker.application.ontology.Node;
import agreementMaker.application.ontology.Ontology;

public abstract class AbstractMatcher implements Matcher{
	
	/**Unique identifier of the algorithm used in the JTable list as index
	 * if an algorithm gets deleted we have to decrease the index of all others by one
	 * */
	private int index;
	/**Name of the algorithm, there should be also a final static String in the instance class
	 * in the constructor of the non-abstract class should happen "name = FINALNAME"
	 * */
	private String name;
	/**User mapping should be the only one with this variable equal to false*/
	private boolean isAutomatic;
	/**True if the algorithm needs parameter, in this case the developer must develop a JFrame to let the user define them*/
	private boolean needsParam;
	/**Parameter of this method, if needsParam this item will be generated by the userinterface if not this will be automatically generated with default values*/
	private AbstractParameters param;
	/**True means that AM should show its alignments*/
	private boolean isShown;
	
	private double threshold;
	
	/**ANY means any numer of relations for source or target*/
	public final static int ANY = -1;
	private int maxSourceAlign;
	private int maxTargetAlign;
	
	/**Contain alignments, NULL if alignment has not been calculated*/
	private AlignmentSet propertiesAlignmentSet;
	private AlignmentSet classesAlignmentSet;
	
	/**Structure containing similarity values between classes nodes, matrix[source][target]
	 * should not be accessible outside of this class, the system should only be able to access alignments sets
	 * */
	private MatrixWithRelations classesMatrix;
	/**Structure containing similarity values between classes nodes, matrix[source][target]*/
	private MatrixWithRelations propertiesMatrix;
	
	/**Reference to the Core istances*/
	private Ontology sourceOntology;
	private Ontology targetOntology;
	
	/**If the algo calculates prop alignments*/
	public boolean alignProp;
	/**If the algo calculates prop alignments*/
	public boolean alignClass;
	
	public AbstractMatcher(int key, String n) {
		index = key;
		name = n;
		isAutomatic = true;
		needsParam = false;
		isShown = true;
		threshold = 0.75;
		maxSourceAlign = ANY;
		maxTargetAlign = 1;
		alignClass = true;
		alignProp = true;
		//ALIGNMENTS LIST MUST BE NULL UNTIL THEY ARE CALCULATED
		sourceOntology = Core.getInstance().getSourceOntology();
		targetOntology = Core.getInstance().getTargetOntology();
	}
	
    public void match() {
    	initMatrix();
    	align();
    	selectAndSetAlignments();
    }

    private void initMatrix() {
    	if(alignClass) {
    		classesMatrix = new MatrixWithRelations(sourceOntology.getClassesList().size(),targetOntology.getClassesList().size());
    	}
		if(alignProp) {
			propertiesMatrix = new MatrixWithRelations(sourceOntology.getPropertiesList().size(),targetOntology.getPropertiesList().size());
		}
	}

	private void selectAndSetAlignments() {
		//CAN BE IMPLEMENTED IN THE SUBCLASSES
		
	}

	private void align() {
		//TO BE IMPLEMENTED IN THE SUBCLASSES BY OVERRIDING
		//IF YOU ARE GOING TO DO A Node BY Node ALIGNMENT YOU CAN AVOID TO OVERRIDE THIS
		//AND OVERRIDE ONLY THE CLASS BY CLASS or Prop by Prop method
		if(alignClass) {
			ArrayList<Node> sourceClassList = sourceOntology.getClassesList();
			ArrayList<Node> targetClassList = targetOntology.getClassesList();
			alignClasses(sourceClassList,targetClassList );			
		}
		if(alignProp) {
			ArrayList<Node> sourcePropList = sourceOntology.getPropertiesList();
			ArrayList<Node> targetPropList = targetOntology.getPropertiesList();
			alignProperties(sourcePropList, targetPropList );					
		}

	}
	


	private void alignProperties(ArrayList<Node> sourcePropList, ArrayList<Node> targetPropList) {
		alignNodesOneByOne(sourcePropList, targetPropList);
	}

	private void alignClasses(ArrayList<Node> sourceClassList, ArrayList<Node> targetClassList) {
		alignNodesOneByOne(sourceClassList, targetClassList);
	}
	
	private void alignNodesOneByOne(ArrayList<Node> sourceList, ArrayList<Node> targetList) {
		Iterator<Node> itsource = sourceList.iterator();
		Iterator<Node> ittarget;
		Node source;
		Node target;
		while(itsource.hasNext()) {
			source = itsource.next();
			ittarget = targetList.iterator();
			while(ittarget.hasNext()) {
				target = ittarget.next();
				alignTwoNodes(source, target);
			}
		}
		
	}

	private void alignTwoNodes(Node source, Node target) {
		//TO BE IMPLEMENTED BY THE ALGORITHM, THIS IS JUST A FAKE ABSTRACT METHOD
		if(source.equals(target)) {
			classesMatrix.set(source.getIndex(), target.getIndex(), 1);
			classesMatrix.setRelation(source.getIndex(), target.getIndex(), MatrixWithRelations.EQUIVALENCE);
		}
			
		
	}

	public AlignmentSet getAlignmentSet() {
    	AlignmentSet aligns = new AlignmentSet();
    	if(areClassesAligned()) {
    		aligns.addAll(classesAlignmentSet);
    	}
    	if(arePropertiesAligned()) {
    		aligns.addAll(propertiesAlignmentSet);
    	}
    	return aligns;
    }

    public AlignmentSet getClassAlignmentSet() {
    	return classesAlignmentSet;
    }

    public AlignmentSet getPropertyAlignmentSet() {
    	return propertiesAlignmentSet;
    }
    /**AgreementMaker doesn't calculate instances matching, if you add this you should also modify getAlignmenSet*/
    public AlignmentSet getInstanceAlignmentSet() {
    	System.out.println("trying to invoking a function not implemented yet");
    	return null;
    }
    
    public boolean areClassesAligned() {
    	return classesAlignmentSet != null;
    }
    
    public boolean arePropertiesAligned() {
    	return propertiesAlignmentSet != null;
    }

	public int getIndex() {
		return index;
	}

	public void setIndex(int index) {
		this.index = index;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public boolean isAutomatic() {
		return isAutomatic;
	}

	public void setAutomatic(boolean isAutomatic) {
		this.isAutomatic = isAutomatic;
	}

	public boolean isNeedsParam() {
		return needsParam;
	}

	public void setNeedsParam(boolean needsParam) {
		this.needsParam = needsParam;
	}

	public AbstractParameters getParam() {
		return param;
	}

	public void setParam(AbstractParameters param) {
		this.param = param;
	}

	public boolean isShown() {
		return isShown;
	}

	public void setShown(boolean isShown) {
		this.isShown = isShown;
	}

	public double getThreshold() {
		return threshold;
	}

	public void setThreshold(double threshold) {
		this.threshold = threshold;
	}

	public int getMaxSourceAlign() {
		return maxSourceAlign;
	}

	public void setMaxSourceAlign(int maxSourceAlign) {
		this.maxSourceAlign = maxSourceAlign;
	}

	public int getMaxTargetAlign() {
		return maxTargetAlign;
	}

	public void setMaxTargetAlign(int maxTargetAlign) {
		this.maxTargetAlign = maxTargetAlign;
	}
    
	
	
}
