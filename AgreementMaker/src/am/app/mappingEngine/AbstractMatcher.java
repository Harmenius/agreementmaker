package am.app.mappingEngine;

import java.awt.Color;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;

import javax.swing.SwingWorker;

import am.AMException;
import am.Utility;
import am.app.Core;
import am.app.mappingEngine.Mapping.MappingRelation;
import am.app.mappingEngine.MatcherChangeEvent.EventType;
import am.app.mappingEngine.oneToOneSelection.MappingMWBM;
import am.app.mappingEngine.oneToOneSelection.MaxWeightBipartiteMatching;
import am.app.mappingEngine.qualityEvaluation.QualityEvaluationData;
import am.app.mappingEngine.referenceAlignment.MatchingPair;
import am.app.mappingEngine.referenceAlignment.ReferenceEvaluationData;
import am.app.mappingEngine.similarityMatrix.ArraySimilarityMatrix;
import am.app.mappingEngine.similarityMatrix.SparseMatrix;
import am.app.ontology.Node;
import am.app.ontology.Ontology;
import am.app.ontology.instance.Instance;
import am.app.ontology.instance.InstanceDataset;
import am.userInterface.MatchingProgressDisplay;

/**
 * transient data are not taken into account while serializing/deserializing the matcher
 * taking transient keyword out of an object means that either you make sure that or you just make it serializable
 * Michele  
 */
public abstract class AbstractMatcher extends SwingWorker<Void, Void> implements Matcher{
	
	/**
	 * Version identifier for this serializable class
	 */
	private static final long serialVersionUID = 1L;
	
	/**Unique identifier of the algorithm used in the JTable list as index
	 * if an algorithm gets deleted we have to decrease the index of all others by one
	 * */
	protected int index;
	/**Name of the algorithm, there should be also a final static String in the instance class
	 * in the constructor of the non-abstract class should happen "name = FINALNAME"
	 * */
	protected MatchersRegistry registryEntry;
	protected String name;
	/**User mapping should be the only one with this variable equal to false*/
	protected boolean isAutomatic;
	/**True if the algorithm needs additional parameter other than threshold, in this case the developer must develop a JFrame to let the user define them*/
	protected boolean needsParam;
	/**Parameter of this method, if needsParam this item will be generated by the userinterface if not this will be automatically generated with default values*/
	protected AbstractParameters param;
	/**Developer will have to instantiate this object in the constructor with real parameterpanel for the method which needs param, if a method don't needs param you don't have to touch this attribute*/
	protected AbstractMatcherParametersPanel parametersPanel;
	/**True means that AM should show its alignments*/
	protected boolean isShown;
	protected boolean modifiedByUser;
	//protected double threshold;
	
	/**ANY means any number of relations for source or target*/
	public final static int ANY_INT = Integer.MAX_VALUE;
	//protected int maxSourceAlign;
	//protected int maxTargetAlign;
	
	/**Contain alignments, NULL if alignment has not been calculated*/
	protected Alignment<Mapping> propertiesAlignmentSet;
	protected Alignment<Mapping> classesAlignmentSet;
	protected List<MatchingPair> instanceAlignmentSet;
	
	/**Structure containing similarity values between classes nodes, matrix[source][target]
	 * should not be accessible outside of this class, the system should only be able to access alignments sets
	 * */
	protected SimilarityMatrix classesMatrix;
	/**Structure containing similarity values between classes nodes, matrix[source][target]*/
	protected SimilarityMatrix propertiesMatrix;
	
	/** The ontologies to be matched. */
	protected transient Ontology sourceOntology;
	protected transient Ontology targetOntology;
	
	protected InstanceDataset sourceInstanceDataset;
	protected InstanceDataset targetInstanceDataset;
	
	
	/**If the algo calculates prop alignments*/
	protected boolean alignProp;
	/**If the algo calculates prop alignments*/
	protected boolean alignClass;
	/** True if the matcher will match instances, false otherwise. */
	protected boolean alignInstances;
	/***Some algorithms may need other algorithms as input*/
	protected ArrayList<AbstractMatcher> inputMatchers;
	/**Minum and maximum number of input matchers
	 * a generic matcher which doesn't need any inputs should have 0, 0
	 * */
	protected int minInputMatchers;
	protected int maxInputMatchers;
	/**Variables needed to calculate execution time, executionTime = (end - start)/ unitMeasure, start has to be init in beforeAlign() and end in aferSelect()*/
	protected long start;
	protected long end;
	protected long executionTime;
	/**Keeps info about reference evaluation of the matcher. is null until the algorithm gets evaluated*/
	protected transient ReferenceEvaluationData refEvaluation;
	/**Keeps info about the quality eval of the matcher. null if the algo is not evaluated*/
	protected transient QualityEvaluationData qualEvaluation;
	/**Graphical color for nodes mapped by this matcher and alignments, this value is set by the MatcherFactory and modified  by the table so a developer just have to pass it as aparameter for the constructor*/
	protected Color color; 
	/**
	 * the matchers combined for example in the LWC matcher can have this set to false, because the partial matchings are not needed. 
	   this parameter is mainly used in batchmode. For the UI has to be set to TRUE. Therefore, the paramter can be set to false, but should always be init to true.
	 *  **/
	protected boolean performSelection;
	
	/** If true, the progress display may not be updated faster than once every 500ms. */
	protected boolean useProgressDelay = true;
	
	public void setPerformSelection(boolean performSelection) {
		this.performSelection = performSelection;
	}
	public void setUseProgressDelay(boolean d ) { useProgressDelay = d; }
	

	/**This enum is for the matching functions that take nodes as an input.  Because we are comparing two kinds of nodes (classes and properties), we need to know the kind of nodes we are comparing in order to lookup up the input similarities in the corrent matrix */
	public enum alignType implements Serializable {
		aligningClasses("CLASSES"),
		aligningProperties("PROPERTIES"),
		unknown("UNKNOWN");

		private final String value;  

		alignType(String value) {  
			this.value = value;  
		}  

		public static alignType fromValue(String value) {  
			if (value != null) {  
				for (alignType en : values()) {  
					if (en.value.equals(value)) {  
						return en;  
					}  
				}  
			}  

			// you may return a default value  
			return getDefault();  
			// or throw an exception  
			// throw new IllegalArgumentException("Invalid color: " + value);  
		}  

		public String toValue() {  
			return value;  
		}  

		public static alignType getDefault() {  
			return unknown;  
		} 
		
		private Object readResolve () throws java.io.ObjectStreamException
	    {
	        if( value == aligningClasses.toValue() ) return aligningClasses;
	        if( value == aligningProperties.toValue() ) return aligningProperties;
	        return unknown;
	    }


	}
	
	protected transient MatchingProgressDisplay progressDisplay = null;  // need to keep track of the dialog in order to close it when we're done.  (there could be a better way to do this, but that's for later)
	protected long stepsTotal; // Used by the ProgressDialog.  This is a rough estimate of the number of steps to be done before we finish the matching.
	protected long stepsDone;  // Used by the ProgressDialog.  This is how many of the total steps we have completed.
	
	protected String report = "";
	
	/**
	 * Right now, matchers only produce equivalence relations
	 * If a matcher computes another type of relation, the relation has to be added to the Alignment class as a static variable
	 * and it has to be set as a default relation in the constructor of that matcher.
	 * at the moment a matcher is not allowed to compute different relations for different concepts
	 * in that case a matrix of relation has to be kept within the matcher and the situation has to be managed properly
	 */
	protected MappingRelation relation;
	
	
	/**
	 * If this value is set to true, the matcher will run in optimized mode
	 * by matching only the concepts that have not been mapped by the matcher in input
	 * For this reason, if this value is set to true another matcher has to be provided in input to this matcher.
	 * When this value is set to true, the maxNumberInputMatcher is also automatically set to 1 in the setOptimized() method.
	 */
	//protected boolean optimized;
	private int matcherID;

	/**
	 * Used by the updateProgress() method.
	 */
	protected long starttime;
	protected long lastTime = 0;
	protected long lastStepsDone = 0;
	protected int tentativealignments = 0;  // incremental selection?
	protected long timeOfLastUpdate = 0;

	
	/**
	 * The constructor must be a Nullary Constructor
	 */
	public AbstractMatcher() {  // index and name will be set by the Matcher Factory
		//ALL MATCHERS HAVE TO INVOKE THIS METHOD THROUGH super() EXCEPT UserManualMatcher
		//therefore by modifying something in this method you may also have to modify the UserManualMatcher
		//while all other matchers will automatically inherit the changes
		initializeVariables();
		param = new AbstractParameters();
	}
	
	public AbstractMatcher( AbstractParameters params_new ) {
		initializeVariables();
		param = params_new;
	}
	
	/**
	 * This function is very important.  It is used by all the constructors to initialize variables when the object is first created.
	 * 
	 * Any matchers that extend AbstractMatcher should override this function with their own if they need to do specific things during the
	 * constructor, but DON'T FORGET TO CALL super.initializeVariables() from their method.
	 * 
	 */
	protected void initializeVariables() {  // TODO: Make this method a PRIVATE method.  If you do that, it should only be called from the constructor. - Cosmin
		//param = new AbstractParameters();
		isAutomatic = true;
		needsParam = false;
		isShown = true;
		modifiedByUser = false;
		performSelection = true;//only in batchmode can be set to false in the internal matchers.
		//threshold = 0.6;
		//maxSourceAlign = 1;
		//maxTargetAlign = 1;
		alignClass = true;
		alignProp = true;
		alignInstances = true;
		minInputMatchers = 0;
		maxInputMatchers = 0;
		relation = MappingRelation.EQUIVALENCE;
		//optimized = false;
		//ALIGNMENTS LIST MUST BE NULL UNTIL THEY ARE CALCULATED
		classesAlignmentSet = null;
		propertiesAlignmentSet = null;
		
		sourceOntology = Core.getInstance().getSourceOntology(); // moved initialization of sourceOntology to match().
		targetOntology = Core.getInstance().getTargetOntology(); // moved initialization of targetOntology to match().
		inputMatchers = new ArrayList<AbstractMatcher>();
	}
	
	
	
	
	
	//***************************ALL METHODS TO PERFORM THE ALIGNMENT**********************************
	/**
	 * Match(), buildSimilarityMatrix() and select() are the only 3 public methods to be accessed by the system other then get and set methods
	 * All other methods must be protected so that only subclasses may access them (can't be private because subclasses wouldn't be able to use them)
	 * match method is the one which perform the alignment. It also invokes the select() to scan and select matchings
	 * the system sometimes may need to invoke only the select method for example when the user changes threshold of an algorithm, it's not needed to invoke the whole matching process but only select
	 * so at least those two methods must be implemented and public
	 * both methods contains some empty methods to allow developers to add other code if needed
	 * In all cases a developer can override the whole match method or use this one and override the methods inside, or use all methods except for alignTwoNodes() which is the one which perform the real aligment evaluation
	 * and it has to be different
	 * 
	 */
	
    public void match() throws Exception {
    	
    	// setup the Ontologies
    	if( sourceOntology == null ) {
    		if( Core.getInstance().getSourceOntology() == null ) {
    			// no source ontology defined or loaded
    			throw new Exception("No source ontology is loaded!");
    		} else {
    			// the source Ontology is not defined, but a Source ontology is loaded in the Core. Use that.
    			sourceOntology = Core.getInstance().getSourceOntology();
    		}
    	}
    	
    	if( targetOntology == null ) {
    		if( Core.getInstance().getTargetOntology() == null ) {
    			// no target ontology defined or loaded
    			throw new Exception("No target ontology is loaded!");
    		} else {
    			// the target Ontology is not defined as part of this matcher, but a Target ontology is loaded in the Core.  Use that.
    			targetOntology = Core.getInstance().getTargetOntology();
    		}
    	}
    	
    	matchStart();
    	buildSimilarityMatrices(); // align()
    	if(performSelection && !this.isCancelled() ){
        	select();	
    	}
    	matchEnd();
    	//System.out.println("Classes alignments found: "+classesAlignmentSet.size());
    	//System.out.println("Properties alignments found: "+propertiesAlignmentSet.size());
    }
    
	/**
	 * Match(), buildSimilarityMatrix() and select() are the only 3 public methods to be accessed by the system other then get and set methods
	 * All other methods must be protected so that only subclasses may access them (can't be private because subclasses wouldn't be able to use them)
	 * match method is the one which perform the alignment. It also invokes the select() to scan and select matchings
	 * the system sometimes may need to invoke only the select method for example when the user changes threshold of an algorithm, it's not needed to invoke the whole matching process but only select
	 * so at least those two methods must be implemented and public
	 * both methods contains some empty methods to allow developers to add other code if needed
	 * In all cases a developer can override the whole match method or use this one and override the methods inside, or use all methods except for alignTwoNodes() which is the one which perform the real aligment evaluation
	 * and it has to be different
	 * It should not be needed often to override the buildSimilarityMatrix(), if you do remember to reinitialize structures everytime at the beginning, and at the end matrices should be filled completely in all cells
	 * It useful to invoke this method instead of the whole matching process while developing a composed matcher which uses other matchers matrices but which doesn't need the alignments sets.
	 * Instead of invoking the whole match() method of each matcher, it can only invoke this one, to avoid the selection process delay.
	 */
	public void buildSimilarityMatrices()throws Exception{
    	beforeAlignOperations();//Template method to allow next developer to add code before align
    	align();
    	afterAlignOperations();//Template method to allow next developer to add code after align
    }


	/**
	 * Match(), buildSimilarityMatrix() and select() are the only 3 public methods to be accessed by the system other then get and set methods
	 * All other methods must be protected so that only subclasses may access them (can't be private because subclasses wouldn't be able to use them)
	 * match method is the one which perform the alignment. It also invokes the select() to scan and select matchings
	 * the system sometimes may need to invoke only the select method for example when the user changes threshold of an algorithm, it's not needed to invoke the whole matching process but only select
	 * so at least those two methods must be implemented and public
	 * both methods contains some empty methods to allow developers to add other code if needed
	 * In all cases a developer can override the whole match method or use this one and override the methods inside, or use all methods except for alignTwoNodes() which is the one which perform the real aligment evaluation
	 * and it has to be different
	 * It should not be needed often to override the select(), in all cases remember to consider all selection parameters threshold, num relations per source and target.
	 */
    public void select() {
    	//this method is also invoked everytime the user change threshold or num relation in the table
    	beforeSelectionOperations();//Template method to allow next developer to add code after selection
    	selectAndSetAlignments();	
    	afterSelectionOperations();//Template method to allow next developer to add code after selection
    }
    
    //***************EMPTY TEMPLATE METHODS TO ALLOW USER TO ADD HIS OWN CODE****************************************

    //reset structures, this is important because anytime we invoke the match() for the secondtime (when we change some values in the table for example)
    //we have to reset all structures. It's the first method that is invoked, when overriding call super.beforeAlignOperations(),
    //IMPORTANT it also takes care of initializing time
	protected void beforeAlignOperations()  throws Exception{
    	classesMatrix = null;
    	propertiesMatrix = null;
    	modifiedByUser = false;
    	qualEvaluation = null;
    	refEvaluation = null;
	}
    //TEMPLATE METHOD TO ALLOW DEVELOPERS TO ADD CODE: call super when overriding
    protected void afterAlignOperations()  {
    	// Setup the ontology IDs of the SimilarityMatrices.
    	if( classesMatrix != null ) {
    		classesMatrix.setSourceOntologyID(sourceOntology.getID());
    		classesMatrix.setTargetOntologyID(targetOntology.getID());
    	}
    	
    	if( propertiesMatrix != null ) {
    		propertiesMatrix.setSourceOntologyID(sourceOntology.getID());
    		propertiesMatrix.setTargetOntologyID(targetOntology.getID());
    	}
    }
    //RESET ALIGNMENT STRUCTURES,     //TEMPLATE METHOD TO ALLOW DEVELOPERS TO ADD CODE: call super when overriding
    public void beforeSelectionOperations() {
    	classesAlignmentSet = null;
    	propertiesAlignmentSet = null;
    	qualEvaluation = null;
    	refEvaluation = null;
    }
    //TEMPLATE METHOD TO ALLOW DEVELOPERS TO ADD CODE: call super when overriding
    protected void afterSelectionOperations() {} 
    
    //Time calculation, if you override this method remember to call super.afterSelectionOperations()
    protected void matchStart() {
    	if( isProgressDisplayed() ) {
    		setupProgress();  // if we are using the progress dialog, setup the variables
    		progressDisplay.matchingStarted(this);
    	}
    	start = System.nanoTime();
    	starttime = System.currentTimeMillis();
    	
	}
    //Time calculation, if you override this method remember to call super.afterSelectionOperations()
	protected void matchEnd() {
		// TODO: Need to make sure this timing is correct.  - Cosmin ( Dec 17th, 2008 )
		end = System.nanoTime();
    	executionTime = (end-start)/1000000; // this time is in milliseconds.
	    setSuccesfullReport();	
		if( isProgressDisplayed() ) {
			allStepsDone();
			progressDisplay.matchingComplete();
		}
    	
	}
    //***************INTERNAL METHODS THAT CAN BE USED BY ANY ABSTRACTMATCHER******************************************
	
	//***************ALIGNING PHASE*****************//

    protected void align() throws Exception {
    	
    	if( sourceOntology == null || targetOntology == null ) return;  // cannot align just one ontology 
    	
		if(alignClass && !this.isCancelled() ) {
			ArrayList<Node> sourceClassList = sourceOntology.getClassesList();
			ArrayList<Node> targetClassList = targetOntology.getClassesList();
			classesMatrix = alignClasses(sourceClassList,targetClassList );	
			//classesMatrix.show();
		}
		if(alignProp && !this.isCancelled() ) {
			ArrayList<Node> sourcePropList = sourceOntology.getPropertiesList();
			ArrayList<Node> targetPropList = targetOntology.getPropertiesList();
			propertiesMatrix = alignProperties(sourcePropList, targetPropList );					
		}
		
		
		if( alignInstances == true && 
		    (sourceOntology.getInstances() == null || targetOntology.getInstances() == null) ) 
		{
			alignInstances = false;
			progressDisplay.appendToReport("Instances were NOT matched since they were not loaded properly.");
		}
		
		if(alignInstances && !this.isCancelled() ) {
			
			sourceInstanceDataset = sourceOntology.getInstances();
			targetInstanceDataset = targetOntology.getInstances();
			
			// compile a list of source instances
			if( !sourceInstanceDataset.isIterable() && !targetInstanceDataset.isIterable() ) {
				throw new AMException("Neither the source or the target instance datasets are iterable.  We cannot instance match.");
			}
			
			if( !sourceInstanceDataset.isIterable() ) {
				throw new AMException("The source MUST be an iterable instance dataset.");
			}
			
			List<Instance> sourceInstances = sourceInstanceDataset.getInstances();
			
			// for every individual in the source list, look for candidate individuals in the target
			instanceAlignmentSet = alignInstances(sourceInstances);
		}

	}

    protected List<MatchingPair> alignInstances(List<Instance> sourceInstances) {
    	
    	List<MatchingPair> mappings = new ArrayList<MatchingPair>();
    	for (Instance sourceInstance: sourceInstances){
    		List<String> labelList = sourceInstance.getProperty("label");
    		String label = labelList.get(0);
			List<Instance> targetCandidates = targetInstanceDataset.getCandidateInstances(label, sourceInstance.getType());
			MatchingPair mapping = alignInstanceCandidates(sourceInstance, targetCandidates);
			
			if(mapping != null) mappings.add(mapping);
			
		}
		return mappings;
	}
    
	protected MatchingPair alignInstanceCandidates(Instance sourceInstance,
			List<Instance> targetCandidates) {
		//TO BE IMPLEMENTED BY THE ALGORITHM, THIS IS JUST A FAKE ABSTRACT METHOD
		return null;
	}
	protected SimilarityMatrix alignProperties(ArrayList<Node> sourcePropList, ArrayList<Node> targetPropList) throws Exception {
    		return alignNodesOneByOne(sourcePropList, targetPropList, alignType.aligningProperties);
	}

    protected SimilarityMatrix alignClasses(ArrayList<Node> sourceClassList, ArrayList<Node> targetClassList)  throws Exception{
			return alignNodesOneByOne(sourceClassList, targetClassList, alignType.aligningClasses);
	}
	
    protected SimilarityMatrix alignNodesOneByOne(ArrayList<Node> sourceList, ArrayList<Node> targetList, alignType typeOfNodes) throws Exception {
    	
    	if((sourceList.size()*targetList.size())>4000000){
    		param.largeOntologyMode=true;
    		System.out.println("running in large ontology mode");
    	}
    	
    	if(param.completionMode && inputMatchers != null && inputMatchers.size() > 0){ 
    		//run in optimized mode by mapping only concepts that have not been mapped in the input matcher
    		if(typeOfNodes.equals(alignType.aligningClasses)){
    			return alignUnmappedNodes(sourceList, targetList, inputMatchers.get(0).getClassesMatrix(), inputMatchers.get(0).getClassAlignmentSet(), alignType.aligningClasses);
    		}
    		else{
    			return alignUnmappedNodes(sourceList, targetList, inputMatchers.get(0).getPropertiesMatrix(), inputMatchers.get(0).getPropertyAlignmentSet(), alignType.aligningProperties);
    		}
		}
    	
    	else if(param.largeOntologyMode ==true){
    		//run as a generic matcher who maps all concepts by doing a quadratic number of comparisons
	    	SimilarityMatrix matrix = new SparseMatrix(sourceList.size(), targetList.size(), typeOfNodes, relation);
			Node source;
			Node target;
			Mapping alignment = null; //Temp structure to keep sim and relation between two nodes, shouldn't be used for this purpose but is ok
			for(int i = 0; i < sourceList.size(); i++) {
				source = sourceList.get(i);
				for(int j = 0; j < targetList.size(); j++) {
					target = targetList.get(j);
					
					if( !this.isCancelled() ) { alignment = alignTwoNodes(source, target, typeOfNodes); }
					else { return matrix; }
					if(alignment != null && alignment.getSimilarity() >= param.threshold)
						matrix.set(i,j,alignment);
					if( isProgressDisplayed() ) {
						stepDone(); // we have completed one step
						if( alignment != null && alignment.getSimilarity() >= param.threshold ) tentativealignments++; // keep track of possible alignments for progress display
					}
				}
				if( isProgressDisplayed() ) updateProgress(); // update the progress dialog, to keep the user informed.
			}
			return matrix;
    	}
    	else{
    		SimilarityMatrix matrix = new ArraySimilarityMatrix(sourceList.size(), targetList.size(), typeOfNodes, relation);
			Node source;
			Node target;
			Mapping alignment = null; //Temp structure to keep sim and relation between two nodes, shouldn't be used for this purpose but is ok
			for(int i = 0; i < sourceList.size(); i++) {
				source = sourceList.get(i);
				for(int j = 0; j < targetList.size(); j++) {
					target = targetList.get(j);
					
					if( !this.isCancelled() ) { alignment = alignTwoNodes(source, target, typeOfNodes); }
					else { return matrix; }
					
					matrix.set(i,j,alignment);
					if( isProgressDisplayed() ) {
						stepDone(); // we have completed one step
						if( alignment != null && alignment.getSimilarity() >= param.threshold ) tentativealignments++; // keep track of possible alignments for progress display
					}
				}
				if( isProgressDisplayed() ) updateProgress(); // update the progress dialog, to keep the user informed.
			}
			return matrix;
    	}
	}
    
    protected SimilarityMatrix alignUnmappedNodes(ArrayList<Node> sourceList, ArrayList<Node> targetList, SimilarityMatrix inputMatrix,
			Alignment<Mapping> inputAlignmentSet, alignType typeOfNodes) throws Exception {
    	
    	MappedNodes mappedNodes = new MappedNodes(sourceList, targetList, inputAlignmentSet, param.maxSourceAlign, param.maxTargetAlign);
    	SimilarityMatrix matrix = new ArraySimilarityMatrix(sourceList.size(), targetList.size(), typeOfNodes, relation);
		Node source;
		Node target;
		Mapping alignment; 
		Mapping inputAlignment;
		for(int i = 0; i < sourceList.size(); i++) {
			source = sourceList.get(i);
			for(int j = 0; j < targetList.size(); j++) {
				target = targetList.get(j);
				
				if( !this.isCancelled() ) {
					//if both nodes have not been mapped yet enough times
					//we map them regularly
					if(!mappedNodes.isSourceMapped(source) && !mappedNodes.isTargetMapped(target)){
						alignment = alignTwoNodes(source, target, typeOfNodes); 
					}
					//else we take the alignment that was computed from the previous matcher
					else{
						inputAlignment = inputMatrix.get(i, j);
						alignment = new Mapping(inputAlignment.getEntity1(), inputAlignment.getEntity2(), inputAlignment.getSimilarity(), inputAlignment.getRelation());
					}
					matrix.set(i,j,alignment);
					if( isProgressDisplayed() ) stepDone(); // we have completed one step
				}
				else { return matrix; }
			}
			if( isProgressDisplayed() ) updateProgress(); // update the progress dialog, to keep the user informed.
		}
		return matrix;
	}
    
    /**This is the main method that will be always ovverriden by the algorithm which perform the similarity between two generic nodes
     * @param source the source concept
     * @param target the target concept
     * @param typeOfNodes can be alignType.alignClasses or alignType.aligningProperties, and it tells you if you in the alignProperties or classes function
     * @return the alignment between the two nodes (a, b, sim, relation)
     * @throws Exception are managed in the doInBackground() method, to interrupt the process to send a message to the user thow new AMException(MESSAGE)
     */
    protected Mapping alignTwoNodes(Node source, Node target, alignType typeOfNodes) throws Exception {
		//TO BE IMPLEMENTED BY THE ALGORITHM, THIS IS JUST A FAKE ABSTRACT METHOD
		double sim;
		MappingRelation rel = MappingRelation.EQUIVALENCE;
		if(source.getLocalName().equals(target.getLocalName())) {
			sim = 1;
		}
		else {
			return null;
		}
		return new Mapping(source, target, sim, rel);
	}
	
	//***************SELECTION PHASE*****************//
    
    protected void selectAndSetAlignments() {
    	if(alignClass) {
    		classesAlignmentSet = scanMatrix(classesMatrix);
    	}
    	if(alignProp) {
    		propertiesAlignmentSet = scanMatrix(propertiesMatrix);
    	}
	}

    protected Alignment<Mapping> scanMatrix(SimilarityMatrix matrix) {
    	if( matrix == null ) { // there is no matrix, return empty set
    		return new Alignment<Mapping>(sourceOntology.getID(), targetOntology.getID());
    	}
    	int columns = matrix.getColumns();
    	int rows = matrix.getRows();
    	// at most each source can be aligned with all targets (columns) it's the same of selecting ANY for source
		int realSourceRelations = Math.min(param.maxSourceAlign, columns);
		// at most each target can be aligned with all sources (rows) it's the same of selecting ANY for target
		int realTargetRelations = Math.min(param.maxTargetAlign, rows);
		
		
		if(realSourceRelations == columns && realTargetRelations == rows) { //ANY TO ANY
			return getThemAll(matrix);
		}
		else if(realSourceRelations != columns && realTargetRelations == rows) { //N - ANY that includes also 1-ANY
			//AT LEAST ONE OF THE TWO CONSTRAINTs IS ANY, SO WE JUST HAVE TO PICK ENOUGH MAX VALUES TO SATISFY OTHER CONSTRAINT 
			return scanForMaxValuesRows(matrix, realSourceRelations);
		}
		else if( realSourceRelations == columns && realTargetRelations != rows) {//ANY-N that includes also ANY-1
			//AT LEAST ONE OF THE TWO CONSTRAINTs IS ANY, SO WE JUST HAVE TO PICK ENOUGH MAX VALUES TO SATISFY OTHER CONSTRAINT 
			return scanForMaxValuesColumns(matrix, realTargetRelations);
    	}
    	else {
			//Both constraints are different from ANY //all cases like 1-1 1-3 or 5-4 or 30-6
			if(realSourceRelations == 1 && realTargetRelations == 1) {//1-1 mapping
				//we can use the hungarian algorithm which provide the optimal solution in polynomial time
				return oneToOneMatching(matrix);
			}
			else { //all cases like 2-2 or 1-3 or 5-4 or 30-6
				//an extension of the stable marriage problem, this is not necesserly optimal but is already more than enough
				return scanWithBothConstraints(matrix, realSourceRelations,realTargetRelations);
			}
		}
	}


	protected Alignment<Mapping> oneToOneMatching(SimilarityMatrix matrix) {
		Alignment<Mapping> aset = new Alignment<Mapping>(sourceOntology.getID(), targetOntology.getID());
		double[][] similarityMatrix = matrix.getCopiedSimilarityMatrix();  // in order of our selection algorithm to be scalable, this has to change! we cannot allocate an NxM matrix if N and M are large! - Cosmin.
		MaxWeightBipartiteMatching<Integer> mwbm = new MaxWeightBipartiteMatching<Integer>(similarityMatrix, param.threshold);
		Collection<MappingMWBM<Integer>> mappings = mwbm.execute();
		Iterator<MappingMWBM<Integer>> it = mappings.iterator();
		Mapping a;
		MappingMWBM<Integer>  m;
		while(it.hasNext()){
			if( this.isCancelled() ) { return null; }
			m = it.next();
			a = matrix.get(m.getSourceNode(), m.getTargetNode());
			if( a != null ) aset.add(a);
		}
		
		/* CODE FOR THE HUNGARIAN
		 * 		//we can use the hungarian algorithm which provide the optimal solution in polynomial time
		//the hungarian can be used to compute the maxim 1-1 matching or the minimum one, and ofc we need the maximum
		double[][] similarityMatrix = matrix.getSimilarityMatrix(); //hungarian alg needs a double matrix
		double[][] cuttedMatrix = Utility.cutMatrix(similarityMatrix, threshold); //those similarity values lower than the threshold cannot be selected so we remove them from the matrix setting them to 0
		int[][] assignments = HungarianAlgorithm.hgAlgorithm(cuttedMatrix, HungarianAlgorithm.MAX_SUM_TYPE);
		
		//the array keeps the assignments
		//if the rows are <= cols assignments are [row][col] else they are [col][row]
		for(int i = 0; i < assignments.length; i++) {
			int row = assignments[i][0];
			int col = assignments[i][1];
			if(matrix.getRows() > matrix.getColumns()) {
				row = assignments[i][1];
				col = assignments[i][0];
			}
			if(row != -1 && col != -1) { //if the node was matched
				Alignment a = matrix.get(row, col);
				//i still need to check this even if similarity values have been cutted because the hungarian algorithm can select also values equals to 0 if there is nothing else
				if(a.getSimilarity() >= threshold)
					aset.addAlignment(a);
			}
		}
		*/
		
		return aset;
	}


    protected Alignment<Mapping> scanForMaxValuesRows(SimilarityMatrix matrix, int numMaxValues) {
		Alignment<Mapping> aset = new Alignment<Mapping>(sourceOntology.getID(), targetOntology.getID());
		Mapping toBeAdded;
		//temp structure to keep the first numMaxValues best alignments for each source
		//when maxRelations are both ANY we could have this structure too big that's why we have checked this case in the previous method
		Mapping[] maxAlignments;
		for(int i = 0; i<matrix.getRows();i++) {
			maxAlignments = matrix.getRowMaxValues(i, numMaxValues);
			//get only the alignments over the threshold
			for(int e = 0;e < maxAlignments.length; e++) { 
				toBeAdded = maxAlignments[e];
				if(toBeAdded != null && toBeAdded.getSimilarity() >= param.threshold) {
					aset.add(toBeAdded);
				}
			}
		}
		return aset;
	}
    

    
    protected Alignment<Mapping> scanForMaxValuesColumns(SimilarityMatrix matrix,int numMaxValues) {
		Alignment<Mapping> aset = new Alignment<Mapping>(sourceOntology.getID(), targetOntology.getID());
		Mapping toBeAdded;
		//temp structure to keep the first numMaxValues best alignments for each source
		//when maxRelations are both ANY we could have this structure too big that's why we have checked this case in the previous method
		Mapping[] maxAlignments;
		for(int i = 0; i<matrix.getColumns();i++) {
			maxAlignments = matrix.getColMaxValues(i, numMaxValues);
			//get only the alignments over the threshold
			for(int e = 0;e < maxAlignments.length; e++) { 
				toBeAdded = maxAlignments[e];
				if(toBeAdded != null && toBeAdded.getSimilarity() >= param.threshold) {
					aset.add(toBeAdded);
				}
			}
		}
		return aset;
	}
    
    /**
     * Returns all mappings that have a similarity value >= the matcher threshold.
     * @param matrix Matrix to scan for mappings.
     * @return Alignment set of mappings. 
     */
    protected Alignment<Mapping> getThemAll(SimilarityMatrix matrix) {
		Alignment<Mapping> aset = new Alignment<Mapping>(sourceOntology.getID(), targetOntology.getID());
		Mapping currentValue;
		for(int i = 0; i<matrix.getColumns();i++) {
			for(int j = 0; j<matrix.getRows();j++) {		
				currentValue = matrix.get(j,i);
				if(currentValue != null && currentValue.getSimilarity() >= param.threshold)
					aset.add(currentValue);
			}
		}
		return aset;
	}

    protected Alignment<Mapping> scanWithBothConstraints(SimilarityMatrix matrix, int sourceConstraint,int targetConstraint) {
    	
    	
    	IntDoublePair fakePair = IntDoublePair.createFakePair();
    	int rows = matrix.getRows();
    	int cols = matrix.getColumns();
    	
    	Alignment<Mapping> aset = new Alignment<Mapping>(sourceOntology.getID(), targetOntology.getID());

    	//I need to build a copy of the similarity matrix to work on it, i just need the similarity values
    	//and i don't need values higher than threshold so i'll just set them as fake so they won't be selected
    	double[][] workingMatrix = new double[rows][cols];
    	double sim;
    	for(int i = 0; i < rows; i++) {
    		for(int j = 0; j < cols; j++) {
    			if( matrix.get(i,j) != null ) {
    				sim = matrix.get(i,j).getSimilarity();
    			} else {
    				sim = 0;
    			}
    			if(sim >= param.threshold)
    				workingMatrix[i][j] = sim;
    			else workingMatrix[i][j] = IntDoublePair.fake;
    		}
    	}
    	
    	//for each source (row) i need to find the SourceConstraint best values
    	//for each maxvalue i need to remember the similarity value and the index of the correspondent column
    	//we init it all to (-1,-1)
    	IntDoublePair[][] rowsMaxValues = new IntDoublePair[matrix.getRows()][sourceConstraint];
    	for(int i= 0; i < rows; i++) {
    		for(int j = 0 ; j < sourceConstraint; j++) {
    			rowsMaxValues[i][j] = fakePair;
    		}
    	}
    	
    	//for each target (column) i need to find the targetConstraint best values
    	//for each maxvalue i need to remember the similarity value and the index of the correspondent column
    	//we init it all to (-1,-1)
    	IntDoublePair[][] colsMaxValues = new IntDoublePair[matrix.getColumns()][targetConstraint];
    	for(int i= 0; i < cols; i++) {
    		for(int j = 0 ; j < targetConstraint; j++) {
    			colsMaxValues[i][j] = fakePair;
    		}
    	}
    	
    	IntDoublePair maxPairOfRow = null;
    	IntDoublePair prevMaxPairOfCol = null;
    	IntDoublePair newMaxPairOfCol = null;
    	
    	//we must continue until the situation is stable
    	//if is a 3-4 mapping it means that we can find at most three alignments for each source and 4 for each target, but not always we can find all
    	boolean somethingChanged = true;
    	while(somethingChanged) {
    		somethingChanged = false;
    		
        	for(int i = 0; i < rows; i++) {
        		
        		//if I haven't found all best alignments for this row
        		if(rowsMaxValues[i][0].isFake()) {
        			
        			//I need to get the max of this row, that is ok also for the column
        			// so the max of this row must be higher the the max previously selected for that column
        			//this do while ends if i find one or if I don't find any so all the cells are fake and the maximum selected is fake too
        			do {
        				//get the max value for this row and the associated column index
                		maxPairOfRow = Utility.getMaxOfRow(workingMatrix, i);

                		if(maxPairOfRow.isFake()) {
                			break; //all the value of these lines are fake
                		}
                		else {
                    		//the minimum of the best values for the column corrisponding to this max
                    		prevMaxPairOfCol = colsMaxValues[maxPairOfRow.index][0];
                    		
                			//and i have to set that matrix value to fake so that that row won't select again that value
                			workingMatrix[i][maxPairOfRow.index] = IntDoublePair.fake;
                		}
        			}
                    while(maxPairOfRow.value <= prevMaxPairOfCol.value);
        			
        			//I don't need the workingMatrix anymore
        			//workingMatrix = null;
        			
            		//if my value is higher than than the minimum of the best values for this column
            		//this value becomes one of the best values and the minimum one is discarded
        			//so if the previous while ended because of the while condition not the break one
        			if(!maxPairOfRow.isFake()) {
        			
            			somethingChanged = true;
            			
            			//this value will be one of the best for this column and row, i had to them and update order.
            			//prevMaxPairOfCol is not anymore one of the best values for this column
            			//i'll switch it with the new one, but i also have to remove it from the best values of his row putting a fake one in it.
            			//i also have to modify the matrix so that that row won't select that max again.
            			newMaxPairOfCol = new IntDoublePair(i,maxPairOfRow.value);
            			colsMaxValues[maxPairOfRow.index][0] = newMaxPairOfCol;
            			//reorder that array of best values of this column to have minimum at the beginning
            			//we have to move the first element to get the right position
            			Utility.adjustOrderPairArray(colsMaxValues[maxPairOfRow.index],0);
            			
            			//the max of this row found must be added to the best values for this row, and then order the array,
            			rowsMaxValues[i][0] = maxPairOfRow;
            			//we have to move the first element to get the right position
            			Utility.adjustOrderPairArray(rowsMaxValues[i],0);
            			
            			
            			if(!prevMaxPairOfCol.isFake()) {
                			//the prev best values has to be removed also from that row best values so i have to find it and set it to fake and reorder
            				for(int k = 0; k < rowsMaxValues[prevMaxPairOfCol.index].length; k++) {
            					if(rowsMaxValues[prevMaxPairOfCol.index][k].index == maxPairOfRow.index) {
            						rowsMaxValues[prevMaxPairOfCol.index][k] = fakePair;
                        			Utility.adjustOrderPairArray(rowsMaxValues[prevMaxPairOfCol.index], k);
            						break;
            					}
            				}
            			}
            		}
        		}
        	}
    	}
    	
    	/*FOR DEBUGGING
    	for(int i = 0; i < rows; i++) {
    		for(int j = 0; j < cols; j++) {
    			System.out.print(workingMatrix[i][j]+" ");
    		}
    		System.out.println("");
    	}
    	*/
    	
    	//now we have the alignments into rowMaxValues
    	IntDoublePair toBeAdded;
    	for(int i = 0; i < rows; i++) {
    		for(int j = 0; j < sourceConstraint; j++) {
    			toBeAdded = rowsMaxValues[i][j];
    			if(!toBeAdded.isFake()) {
        			aset.add(matrix.get(i,toBeAdded.index));
    			}
    		}
    	}
    	
  
    	return aset;
    }
   

	//*****************USER ALIGN METHOD*****************************
    
	public void addManualAlignments(ArrayList<Mapping> alignments) throws Exception {
		Iterator<Mapping> it = alignments.iterator();
		Mapping al;
		while(it.hasNext()) {
			al = it.next();
			if( al == null ) continue;  // TODO: Figure out why al would be null.
			if(al.getEntity1().isClass() && al.getEntity2().isClass()) {
				if(alignClass) {
					addManualClassAlignment(al) ;
				}
			}
			else if(al.getEntity1().isProp() && al.getEntity2().isProp()) {
				if(alignProp) {
					addManualPropAlignment(al) ;
				}
			}
		}
		select();
		modifiedByUser = true;
	}
		
    public void addManualClassAlignment(Mapping a) throws Exception {
    	if( classesMatrix == null ) throw new Exception("The classMatrix is not initialized."); 
    	if( a == null ) throw new Exception("Cannot set a null alignment.");
    	addManualAlignment(a, classesMatrix);
    }

    public void addManualPropAlignment(Mapping a) throws Exception {
    	if( classesMatrix == null ) throw new Exception("The propertiesMatrix is not initialized."); 
    	if( a == null ) throw new Exception("Cannot set a null alignment.");
    	addManualAlignment(a, propertiesMatrix);
    }
    
    public void addManualAlignment(Mapping a, SimilarityMatrix matrix) {
    	matrix.set(a.getEntity1().getIndex(), a.getEntity2().getIndex(), a);
    }
    
	//*****************SET AND GET methods ******************************************
	public AbstractMatcherParametersPanel getParametersPanel() {
		//This method must create and return the AbstractMatcherParameter subclass so that the user can select additional parameters needed by the matcher
		//if the matcher doesn't need any parameter then the attribute needsParameters must be false and this method won't be invoked.
		//REMEMBER to instantiate the panel in this method. Don't initiate the panel in the constructor because the method runs in batch mode the panel is not needed.
		throw new RuntimeException("The method getParametersPanel has to be implemented in the implementing class");
		//You may need to override this method to pass some more information to the panel, in that case instead of initializing the panel in the constructor 
		//you will have to override this method this way: "return new MyParameterPanel(with some more parameters); (see manualCombinationMatcher structure
	}
	
	public Alignment<Mapping> getAlignment() {
    	Alignment<Mapping> aligns = new Alignment<Mapping>(sourceOntology.getID(), targetOntology.getID());
    	if(areClassesAligned()) {
    		aligns.addAll(classesAlignmentSet);
    	}
    	if(arePropertiesAligned()) {
    		aligns.addAll(propertiesAlignmentSet);
    	}
    	return aligns;
    }

    public Alignment<Mapping> getClassAlignmentSet() {
    	return classesAlignmentSet;
    }

    public Alignment<Mapping> getPropertyAlignmentSet() {
    	return propertiesAlignmentSet;
    }
    /**AgreementMaker doesn't calculate instances matching, if you add this you should also modify getAlignmenSet*/
    public Alignment<Mapping> getInstanceAlignmentSet() {
    	throw new RuntimeException("trying to invoking a function not implemented yet");
    }
    
    public boolean areClassesAligned() {
    	return classesAlignmentSet != null;
    }
    
   
    public boolean arePropertiesAligned() {
    	return propertiesAlignmentSet != null;
    }
    
    public boolean isSomethingAligned() {
    	return areClassesAligned() || arePropertiesAligned();
    }
    
    public int getNumberClassAlignments() {
    	int numAlign = 0;
		if(areClassesAligned()) {
			numAlign += getClassAlignmentSet().size();
		}
		return numAlign;
    }
    
    public int getNumberPropAlignments() {
    	int numAlign = 0;
		if(arePropertiesAligned()) {
			numAlign += getPropertyAlignmentSet().size();
		}
		return numAlign;
    }
    
    public int getTotalNumberAlignments() {
    	return getNumberClassAlignments()+getNumberPropAlignments();
    }

	public int getIndex() {
		return index;
	}

	public void setIndex(int index) {
		this.index = index;
	}

	public String getName() { return name != null ? name : registryEntry.getMatcherName(); }
	public void setName(String n) { name = n; } 
	public MatchersRegistry getRegistryEntry() { return registryEntry; }
	public void setRegistryEntry(MatchersRegistry name) { this.registryEntry = name; }

	public boolean isAutomatic() { return isAutomatic; }
	public void setAutomatic(boolean isAutomatic) { this.isAutomatic = isAutomatic; }

	public boolean needsParam() { return needsParam; }
	public void setNeedsParam(boolean needsParam) { this.needsParam = needsParam; }

	public boolean isCompletionMode() { return param.completionMode; }
	
	public AbstractParameters getParam() {
		return param;
	}

	public void setParam(AbstractParameters param) {
		this.param = param;
	}

	public boolean isShown() {
		return isShown;
	}

	public void setShown(boolean isShown) {
		this.isShown = isShown;
		
		// fire an event to let all the listeners know that the visibility of this abstract matcher
		MatcherChangeEvent evt = new MatcherChangeEvent(this, MatcherChangeEvent.EventType.MATCHER_VISIBILITY_CHANGED, getID());
		Core.getInstance().fireEvent(evt);
	}
	
	public boolean getShown() { return isShown; }
	

	public double getThreshold() {
		return param.threshold;
	}

	public void setThreshold(double threshold) {
		if( param == null ) { param = new AbstractParameters() {}; }
		param.threshold = threshold;
	}

	public int getMaxSourceAlign() {
		return param.maxSourceAlign;
	}

	public void setMaxSourceAlign(int maxSourceAlign) {
		param.maxSourceAlign = maxSourceAlign;
	}

	public int getMaxTargetAlign() {
		return param.maxTargetAlign;
	}

	public void setMaxTargetAlign(int maxTargetAlign) {
		param.maxTargetAlign = maxTargetAlign;
	}

	
	
	public int getMinInputMatchers() {
		return minInputMatchers;
	}

	public void setMinInputMatchers(int minInputMatchers) {
		this.minInputMatchers = minInputMatchers;
	}

	public int getMaxInputMatchers() {
		return maxInputMatchers;
	}

	public void setMaxInputMatchers(int maxInputMatchers) {
		this.maxInputMatchers = maxInputMatchers;
	}

	public ArrayList<AbstractMatcher> getInputMatchers() {
		return inputMatchers;
	}
    
	public void addInputMatcher(AbstractMatcher a) {
		inputMatchers.add(a);
	}

	public boolean isModifiedByUser() {
		return modifiedByUser;
	}

	public void setModifiedByUser(boolean modifiedByUser) {
		this.modifiedByUser = modifiedByUser;
	}

	public ReferenceEvaluationData getRefEvaluation() {
		return refEvaluation;
	}

	public void setRefEvaluation(ReferenceEvaluationData evaluation) {
		this.refEvaluation = evaluation;
	}
	
	public boolean isRefEvaluated() {
		return refEvaluation != null;
	}
	
	public QualityEvaluationData getQualEvaluation() {
		return qualEvaluation;
	}

	public void setQualEvaluation(QualityEvaluationData qualEvaluation) {
		this.qualEvaluation = qualEvaluation;
	}
	
	public boolean isQualEvaluated() {
		return qualEvaluation != null;
	}
	
	
	public boolean isAlignProp() {
		return alignProp;
	}

	public boolean isAlignClass() {
		return alignClass;
	}

	public void setAlignProp(boolean alignProp) {
		this.alignProp = alignProp;
	}

	public void setAlignClass(boolean alignClass) {
		this.alignClass = alignClass;
	}
	
	public SimilarityMatrix getClassesMatrix() {
		return classesMatrix;
	}

	public SimilarityMatrix getPropertiesMatrix() {
		return propertiesMatrix;
	}
	
	public long getExecutionTime() {
		return executionTime;
	}

	public void setExecutionTime(long executionTime) {
		this.executionTime = executionTime;
	}
	
	public void setInputMatchers(ArrayList<AbstractMatcher> inputMatchers) {
		this.inputMatchers = inputMatchers;
	}
	//***********************MEthods used by the interface for some small tasks**************************
	
	/**
	 * Matcher details you can override this method to add or change you matcher details if needed, it is only invoked clicking on the button view details in the control panel
	 * @return a string with details of the matchers
	 */
	public String getDetails() {
		String s = "";
		s+= "Matcher: "+getName()+"\n\n";
		s+= "Brief Description:\n\n";
		s += getDescriptionString()+"\n";
		s += "Characteristics\n\n";
		s += getAttributesString()+"\n";
		s += "References\n\n";
		s += getReferenceString()+"\n";
		return s;
	}
	
	public String getAttributesString() {
		String s = "";
		s+= "Additional parameters required: "+Utility.getYesNo(needsParam())+"\n";
		s+= "Min number of matchers in input: "+Utility.getStringFromNumRelInt(getMinInputMatchers())+"\n";
		s+= "Max number of matchers in input: "+Utility.getStringFromNumRelInt(getMaxInputMatchers())+"\n";
		s+= "Performs Classes alignment: "+Utility.getYesNo(isAlignClass())+"\n";
		s+= "Performs Properties alignment: "+Utility.getYesNo(isAlignProp())+"\n";
		return s;
	}
	/**
	 * All matchers should implement this method to return a description of the algorithm used, the String should finish with \n;
	 * @return
	 */
	public String getDescriptionString() {
		return "No description available for this matcher\n";
	}
	public String getReferenceString() {
		return "No references available for this matcher\n";
	}

	/**These 3 methods are invoked any time the user select a matcher in the matcherscombobox. Usually developers don't have to override these methods unless their default values are different from these.*/
	public double getDefaultThreshold() {
		// TODO Auto-generated method stub
		return 0.6;
	}
	
	/**These 3 methods are invoked any time the user select a matcher in the matcherscombobox. Usually developers don't have to override these methods unless their default values are different from these.*/
	public int getDefaultMaxSourceRelations() {
		// TODO Auto-generated method stub
		return 1;
	}

	/**These 3 methods are invoked any time the user select a matcher in the matcherscombobox. Usually developers don't have to override these methods unless their default values are different from these.*/
	public int getDefaultMaxTargetRelations() {
		// TODO Auto-generated method stub
		return 1;
	}
	
	/**This method is invoked at the end of the matching process if the process successed, to give a feedback to the user. Developers can ovveride it to add additional informations.
	 * Developers can also add a global variable like message that is set dinamically during the matching process to have different type of feedback.
	 * **/
	
	public void setSuccesfullReport() {
		report =  "Matching Process Complete Succesfully!\n\n";
		if(areClassesAligned()) {
			report+= "Classes alignments found: "+classesAlignmentSet.size()+"\n";
		}
		if(arePropertiesAligned()) {
			report+= "Properties alignments found: "+propertiesAlignmentSet.size()+"\n";
		}
		if(executionTime != 0) {
			report += "Total execution time (h:m:s:ms): "+Utility.getFormattedTime(executionTime)+"\n";
		}
	}
	
	public String getReport() {
		return report;
	}

	public void setReport(String report) {
		this.report = report;
	}
	
	public MappingRelation getRelation() {
		return relation;
	}

	public void setRelation(MappingRelation relation) {
		this.relation = relation;
	}     
	
	public boolean isOptimized() {
		return param.completionMode;
	}

	public void setOptimized(boolean optimized) {
		param.completionMode = optimized;
		if(maxInputMatchers < 1){
			maxInputMatchers = 1;
		}
	}
	
	public String getAlignmentsStrings() {
		//The small arrow must be different from the bigger used in the alignments or the parseReference will identify these lines as alignments
		String result = "";
		result+= "Class Alignments: "+classesAlignmentSet.size()+"\n";
		result += "Source Concept\t ->\tTarget Concept\tSimilarity\tRelation\n\n";
		result += classesAlignmentSet.getStringList();
		result+= "Property Alignments: "+propertiesAlignmentSet.size()+"\n";
		result += "Source Concept\t->\tTarget Concept\tSimilarity\tRelation\n\n";
		result += propertiesAlignmentSet.getStringList();
		return result;
	}
	
	public AbstractMatcher copy() throws Exception {
		AbstractMatcher cloned = MatcherFactory.getMatcherInstance(getRegistryEntry(), Core.getInstance().getMatcherInstances().size());
		cloned.setInputMatchers(getInputMatchers());
		cloned.setParam(getParam());
		cloned.setThreshold(getThreshold());
		cloned.setMaxSourceAlign(getMaxSourceAlign());
		cloned.setMaxTargetAlign(getMaxTargetAlign());
		cloned.setAlignClass(isAlignClass());
		cloned.setAlignProp(isAlignProp());
		cloned.match();
		return cloned;
		
	}
	
	public Color getColor() { return color; }
	public void setColor(Color color) { 
		this.color = color;
		MatcherChangeEvent mce = new MatcherChangeEvent(this, MatcherChangeEvent.EventType.MATCHER_COLOR_CHANGED);
		Core.getInstance().fireEvent(mce);
	}
	
	//*************************UTILITY METHODS**************************************
	public boolean equals(Object o) {
		if(o instanceof AbstractMatcher) {
			AbstractMatcher a = (AbstractMatcher)o;
			return a.getIndex() == this.getIndex();
		}
		return false;
	}
	
	public int hashCode() {
		return index;
	}

	
	//****************** PROGRESS DIALOG METHODS *************************8
	
	
    /**
     * This function is used by the Progress Dialog, in order to invoke the matcher.
     * It's just a wrapper for match(). 
     */
	public Void doInBackground() throws Exception {
		try {
			//without the try catch, the exception got lost in this thread, and we can't debug
			match();
		}
		catch(AMException ex2) {
			
			report += "\nUnexpected error.\n";
			
			String message = ex2.getMessage();
			if( !(message == null || message.isEmpty()) ) report += ex2.getMessage() + "\n";
			else report += ex2.toString();
			
			ex2.printStackTrace();
			this.cancel(true);
			if( progressDisplay != null ) {
				progressDisplay.appendToReport(report);
				progressDisplay.matchingComplete(); 
			}
		}
		catch(Exception ex) {
			report += "\nUnexpected error.\n";

			String message = ex.getMessage();
			if( !(message == null || message.isEmpty()) ) report += ex.getMessage() + "\n";
			else report += ex.toString();
			
			ex.printStackTrace();
			this.cancel(true);
			if( progressDisplay != null ) {
				progressDisplay.appendToReport(report);
				progressDisplay.matchingComplete(); 
			}
		}
		return null;
	}
    
    /**
     * Function called by the worker thread when the matcher finishes the algorithm.
     */
    /*public void done() {
    	if( isProgressDisplayed() ) progressDisplay.matchingComplete();  // when we're done, close the progress dialog
    }*/
	
    /**
     * Need to keep track of the progress dialog we have because right now, there is no button to close it, so we must make it close automatically.
     * @param p
     */
	public void setProgressDisplay( MatchingProgressDisplay p ) {
		if( progressDisplay != null && p != progressDisplay ) {
			removePropertyChangeListener(progressDisplay);
		}
		progressDisplay = p;
		if( p != null ) addPropertyChangeListener(p);
	}
	
	
    /**
     * getProgressDisplay
     * @param p
     */
	public MatchingProgressDisplay getProgressDisplay() {
		return progressDisplay;
	}
	
	/**
	 * This method sets up stepsDone and stepsTotal.  Override this method if you have a special way of computing the values.
	 * ( If you override this method, it's likely that you will also need to override alignNodesOneByOne(), because it calls stepDone() and updateProgress() ).
	 * @author Cosmin Stroe @date Dec 17, 2008
	 */
	protected void setupProgress() {
    	stepsDone = 0;
    	stepsTotal = 0;  // total number
    	if( alignClass ) {
    		int n = sourceOntology.getClassesList().size();
    		int m = targetOntology.getClassesList().size();
    		stepsTotal += n*m;  // total number of comparisons between the class nodes 
    	}
    	
    	if( alignProp ) {
    		int n = sourceOntology.getPropertiesList().size();
    		int m = targetOntology.getPropertiesList().size();
    		stepsTotal += n*m; // total number of comparisons between the properties nodes
    	}

    	// we have computed stepsTotal, and initialized stepsDone to 0.
    	setProgress(0);
	}

	/**
	 * We have just completed one step of the total number of steps.
	 * 
	 * Remember, stepsDone is used in conjunction with stepsTotal, in order to get 
	 * an idea of how much of the total task we have done ( % done = stepsDone / stepsTotal * 100 ).
	 * 
	 *  @author Cosmin Stroe @date Dec 17, 2008
	 */
	protected void stepDone() {
		stepsDone++;
	}


	/**
	 * Update the Progress Dialog with the current progress.
	 * 
	 *  @author Cosmin Stroe @date Dec 17, 2008
	 *  @author Cosmin Stroe @date Oct 1, 2010 @comment Updated to display estimated total time and estimated time left.  
	 */	
	protected void updateProgress() {

		long currentTime = System.currentTimeMillis();
		if( !useProgressDelay || currentTime - timeOfLastUpdate > 500 ) {
			timeOfLastUpdate = currentTime;
			long elapsedTime = currentTime - lastTime;
			long elapsedSteps = stepsDone - lastStepsDone;
			long totalelapsed = currentTime - starttime; // elapsed time since the start of the algorithm
			
			long estimatedDuration = elapsedSteps == 0 ? 0 : elapsedTime * ( stepsTotal / elapsedSteps );
			long estimatedtimeleft = stepsDone == 0 ? 0 : ((stepsTotal - stepsDone) * totalelapsed) / stepsDone;   
			
			String formattedTime = Utility.getFormattedTime(estimatedDuration);
			
			float percent = stepsTotal == 0 ? 0f : ((float)stepsDone / (float)stepsTotal);
			
			progressDisplay.clearReport();
			progressDisplay.appendToReport( "Percentage done: " + Float.toString(percent* 100.0f)+ "%\n" +
											"Current duration: " + Utility.getFormattedTime(totalelapsed) + "\n" +  
											"Time left ~: " + Utility.getFormattedTime(estimatedtimeleft) + "\n" +
											"Total Duration ~: " + formattedTime + "\n" +
											"Mappings >= threshold: " + tentativealignments + "\n");
			
			lastTime = currentTime;
			lastStepsDone = stepsDone;
			
			Float p_f = new Float(percent * 100.0f);
			int p = p_f.intValue();
			
			// some error checking
			if( p > 100 && p > 0 ) { p = 100; }
			if( p < 0 ) { p = 0; }
			setProgress(p);  // this function does the actual work ( via Swingworker, which uses the PropertyChangeListener )
		}
		
	}
	
	/**
	 * Should only be called while the matcher is still runnning.
	 * @return The time in milliseconds that the matcher has been running.
	 */
	public long getRunningTime() {
		return System.currentTimeMillis() - lastTime;
	}
	
	/**
	 * If the matcher implemented by a developer doesn't take care of the progress
	 * for example it overrides the align method and doesn't write any code to increase steps
	 * in that case we have to force the progress to be 100% at the end
	 * It is used into matchEnd() method.
	 * For the same reason setupProgress is inside matchStart();
	 * Assuming that a developer shouldn't change match() or matchStart() or matchEnd()
	 */
	
	protected void allStepsDone() {
		if( stepsTotal <= 0 ) stepsTotal = 1; // avoid division by 0;
		if(stepsDone != stepsTotal) {
			stepsDone = stepsTotal;
			updateProgress();
		}
	}
	
	/**
	 * If a matcher invokes the match() method of another matcher internally, the internal matcher 
	 * won't have the progressDisplay, and the globalstaticvariable may be still true
	 * so we have to check both conditions
	 */
	public boolean isProgressDisplayed() {
		return progressDisplay != null;  // don't need to check for the global static variable, since if it's false, we should never have to call this function
	}

	public void setPropertiesAlignmentSet(Alignment<Mapping> propertiesAlignmentSet) {
		this.propertiesAlignmentSet = propertiesAlignmentSet;
	}

	public void setClassesAlignmentSet(Alignment<Mapping> classesAlignmentSet) {
		this.classesAlignmentSet = classesAlignmentSet;
	}

	public void setID(int nextMatcherID) { matcherID = nextMatcherID; }
	public int  getID()                  { return matcherID; }

	// 
	/**
	 * this method removes any mappings between these two nodes
	 * 
	 * @param source The source concept.
	 * @param target The target concept.  Must be the same type of concept as the source. 
	 */
	public void removeMapping(Node source, Node target) {

		if( (source.isClass() && target.isProp()) || (source.isProp() && target.isClass()) ) {
			// cannot have mappings between non matching types of concepts
			return;
		}
		
		alignType type = alignType.aligningClasses;
		if( source.isProp() ) type = alignType.aligningProperties;
		
		
		Alignment<Mapping> workingSet = null;
		SimilarityMatrix workingMatrix = null;
		if( type == alignType.aligningClasses ) {
			workingSet = classesAlignmentSet;
			workingMatrix = classesMatrix;
		} else {
			workingSet = propertiesAlignmentSet;
			workingMatrix = propertiesMatrix;
		}
		
		Mapping a = workingSet.contains(source, target);
		if( a == null ) { return; } // this mapping does not exist.
		
		// delete the alignment from the matrix
		
		int row = source.getIndex();
		int col = target.getIndex();
		
		if( row < workingMatrix.getRows() && col < workingMatrix.getColumns() ) {
			Mapping a2 = workingMatrix.get( row, col );
			if( a.equals(a2) ) {
				// ding ding ding, we have a winner.
				workingMatrix.set(row, col, null); // delete the alignment
			}
		}/* else {
			// swap the row and col values 
			row = target.getIndex();
			col = source.getIndex();
			
			if( row < workingMatrix.getRows() && col < workingMatrix.getColumns() ) {
				Mapping a2 = workingMatrix.get(row, col);
				if( a.equals(a2) ) {
					// ding ding ding, we have a winner.
					workingMatrix.set(row,col, null); // delete the alignment
				}
			}
		}*/
		
		// delete the alignment from the alignment set
		// don't know if the order will be correct, so try both.
		workingSet.remove(a);
		/*if( !workingSet.removeAlignment(source, target) ) {
			if( !workingSet.removeAlignment(target, source) ) {
				// should never get here
			}
		}*/
		
		// make sure we let our listeners know that we changed the alignment set
		Core.getInstance().fireEvent( new MatcherChangeEvent(this, 
				EventType.MATCHER_ALIGNMENTSET_UPDATED, this.matcherID) );
		
	}
	
	// 
	/**
	 * this method removes any mappings between these two nodes
	 * 
	 * @param source The source concept.
	 * @param target The target concept.  Must be the same type of concept as the source. 
	 */
	public Mapping getMapping(Node source, Node target) {

		if( (source.isClass() && target.isProp()) || (source.isProp() && target.isClass()) ) {
			// cannot have mappings between non matching types of concepts
			return null;
		}
		
		if( source.isClass() )	return classesAlignmentSet.contains(source, target);
		if( source.isProp() ) return propertiesAlignmentSet.contains(source, target);
		return null;
	}
	

	
	/***************** Ontology methods **************************/
	
	public Ontology getSourceOntology() { return sourceOntology; }
	public Ontology getTargetOntology() { return targetOntology; }
	
	public void setSourceOntology( Ontology s ) { sourceOntology = s; }
	public void setTargetOntology( Ontology t ) { targetOntology = t; }
	public void setOntologies( Ontology source, Ontology target ) { sourceOntology = source; targetOntology = target; } // convenience function


	/** ****************** Serialization methods *******************/
	
	  /**
	   * readObject: gets the state of the object.
	   * @author michele
	   */
	  public static AbstractMatcher readObject(ObjectInputStream in) throws ClassNotFoundException, IOException {
		  AbstractMatcher thisClass = (AbstractMatcher) in.readObject();
		  in.close();
		  return thisClass;
	  }

	   /**
	    * writeObject: saves the state of the object.
	    * @author michele
	    */
	  public void writeObject(ObjectOutputStream out) throws IOException {
		  out.writeObject(this);
		  out.close();
	  }


/***********************************************************************************************
 ************************************* MATCHER FEATURES ****************************************
 ***********************************************************************************************/
	  
	  // List of features supported by this matcher.
	  protected List<MatcherFeature> supportedFeatures = null;

	  /**
	   * Determine if a feature is supported by a specific matcher.
	   * These features must be setup in the constructor.
	   * @param f Feature to check for.
	   * @return true if feature is supported, false otherwise.
	   */
	  public boolean supportsFeature( MatcherFeature f ) { 
		  if( supportedFeatures != null ) return supportedFeatures.contains(f); 
		  return false;
	  }
	  
	  protected void addFeature ( MatcherFeature f ) { 
		  if( !supportsFeature(f) ) { 
			  if( supportedFeatures == null ) supportedFeatures = new ArrayList<MatcherFeature>(); 
			  supportedFeatures.add(f); 
		  }
	  }
}
